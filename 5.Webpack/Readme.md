## 这个文档是一个大佬总结的，推荐给大家学习；我自己还没看完，有些东西太难理解了；
1. 构建过程： 
   1. 合并配置文件（默认配置、cli参数配置、文件配置）
   2. 根据主入口文件进行读取模块文件 =》读取文件内容 =》 解析文件内容 =》 loader代码转换 =》 构建抽象语法书分析以来 =》 记录依赖到dependences中 =》 转换依赖函数 =》 把require转换成__webpack_require__ =》 把当前的文件的解析内容保存到一个资源列表当中（以文件路径为key => 文件内容为值保存） =》 根据之前的dependences继续分析依赖 =》 他会先做判断当前需要解析的模块文件**在资源列表有没有保存**，如果没有就继续 =》 读取文件内容 ... =》最后生成一个总的chunk资裂表（chunk里面记录就是每一个模块文件，文件记录chunkhash）
   3. 输出总的bundle.js或者hash文件。至此结束
2. loader  代码转换作用，比如 css他会根据源码转换成一个（转换过后hash类名）字符串、以及module的hash值与自己类名的健值对；再通过style来document创建一个style标签，把字符串通过innerHtml插入进去；这也就是style需要顺序写在前面（loader从右向左解析）；而预解析语言less写在最后面，定义自己的一套css写法规则。 file-loader也是把文件转换成一个base64文件
3. plugin  构建时依赖一个compliyer对象，构建过程中确实用的complition对象。plugin本身也是一个带有apply方法的对象，所有plugin都在此方法里面注册钩子函数来实现plugin的作用
4. 热替换原理  HMR ，向源文件插入 module.hot 和 module.hot.accept 相关代码；webpack服务器会通过socket管道通知哪个文件进行了更改。再通过一个插件（插件名不记得了。插件是真记不住，自行googel）转换代码。再重新reload页面
5. 优化  cache-loader缓存 、模块文件免解析（noparse）、tree-shaking（依赖import 必须写在头部且引入可以按照属性字符串形式按需引入）、压缩代码（去掉死代码）、gzip（浏览器欲压缩）、分包、等等等

**总结：学习webpack相关原理是为了让我们更好的开发，现在大多利用构建工具，有的人却说不影响开发，这是错的，学习它可以让我们更好的知道构建工具构建出来的文件到底有什么用，比如我用Umi构建工具,好奇心就促使我知道cache文件什么用，dll文件有什么用，如果以后自己成为架构师，亲自搭项目也是很好的**
   